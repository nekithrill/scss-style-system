@use 'sass:map';
@use 'sass:meta';
@use '../functions/px-to-rem' as *;

/// Generate CSS variables from design token maps
/// Automatically detects nested (colors) vs flat (spacing) structure
/// Optionally transforms px values to rem
///
/// @param {Map} $tokens - Token configuration with groups
///
/// Token structure:
/// $tokens: (
///   group-name: (
///     map: $map-data,           // Required: token values
///     prefix: 'prefix',         // Required: CSS variable prefix
///     transform: 'rem',         // Optional: convert px to rem
///   ),
/// )
///
/// @example scss - Input
///   $tokens: (
///     colors: (
///       map: (
///         'primary': (100: #e0e7ff, 500: #6366f1),
///         'success': (bg: #d1fae5, solid: #10b981)
///       ),
///       prefix: 'clr',
///     ),
///     spacing: (
///       map: (1: 4px, 2: 8px, 4: 16px),
///       prefix: 'sp',
///       transform: 'rem',
///     ),
///   );
///
///   :root {
///     @include generate-tokens($tokens);
///   }
///
/// @example css - Output
///   :root {
///     /* Nested maps (colors) */
///     --clr-primary-100: #e0e7ff;
///     --clr-primary-500: #6366f1;
///     --clr-success-bg: #d1fae5;
///     --clr-success-solid: #10b981;
///
///     /* Flat maps (spacing with transform) */
///     --sp-1: 0.25rem;
///     --sp-2: 0.5rem;
///     --sp-4: 1rem;
///   }

@mixin generate-tokens($tokens) {
	@each $group-name, $config in $tokens {
		$map: map.get($config, 'map');
		$prefix: map.get($config, 'prefix');
		$transform: map.get($config, 'transform');

		@if not $map {
			@error "generate-tokens: Group '#{$group-name}' missing 'map' key";
		}

		@if not $prefix {
			@error "generate-tokens: Group '#{$group-name}' missing 'prefix' key";
		}

		$is-nested: _is-nested-map($map);

		@if $is-nested {
			// NESTED: --prefix-palette-shade (e.g., --clr-primary-500)
			@each $palette-name, $palette in $map {
				@if meta.type-of($palette) == 'map' {
					@each $shade, $value in $palette {
						$final-value: if($transform == 'rem', px-to-rem($value), $value);
						--#{$prefix}-#{$palette-name}-#{$shade}: #{$final-value};
					}
				}
			}
		} @else {
			// FLAT: --prefix-name (e.g., --sp-4, --fw-bold)
			@each $key, $value in $map {
				$final-value: if($transform == 'rem', px-to-rem($value), $value);
				--#{$prefix}-#{$key}: #{$final-value};
			}
		}
	}
}

/// Check if map contains nested maps (first value is a map)
/// @access private

@function _is-nested-map($map) {
	@if meta.type-of($map) != 'map' {
		@return false;
	}
	@each $key, $value in $map {
		@return meta.type-of($value) == 'map';
	}
	@return false;
}
