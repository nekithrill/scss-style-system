@use 'sass:map';
@use 'sass:meta';
@use '../functions/px-to-rem' as *;

/// Generate CSS variables from design token maps
/// Supports nested maps (colors) and flat maps (spacing, typography, etc.)
/// Optionally transforms values using px-to-rem conversion
///
/// @param {Map} $tokens - Token configuration with groups
///
/// Token structure:
/// $tokens: (
///   group-name: (
///     map: $map-data,           // Required: token values
///     prefix: 'prefix',         // Required: CSS variable prefix
///     transform: 'rem',         // Optional: convert px to rem
///   ),
/// )
///
/// @example scss
///   $tokens: (
///     colors: (
///       map: $all-palettes,
///       prefix: 'clr',
///     ),
///     spacing: (
///       map: $spacing,
///       prefix: 'sp',
///       transform: 'rem',
///     ),
///   );
///
///   :root {
///     @include generate-tokens($tokens);
///   }

@mixin generate-tokens($tokens) {
	@each $group-name, $config in $tokens {
		$map: map.get($config, 'map');
		$prefix: map.get($config, 'prefix');
		$transform: map.get($config, 'transform');

		@if not $map {
			@error "generate-tokens: Group '#{$group-name}' missing 'map' key";
		}

		@if not $prefix {
			@error "generate-tokens: Group '#{$group-name}' missing 'prefix' key";
		}

		$is-nested: _is-nested-map($map);

		@if $is-nested {
			// NESTED: --prefix-palette-shade (e.g., --clr-primary-500)
			@each $palette-name, $palette in $map {
				@if meta.type-of($palette) == 'map' {
					@each $shade, $value in $palette {
						$final-value: if($transform == 'rem', px-to-rem($value), $value);
						--#{$prefix}-#{$palette-name}-#{$shade}: #{$final-value};
					}
				}
			}
		} @else {
			// FLAT: --prefix-name (e.g., --sp-4, --fw-bold)
			@each $key, $value in $map {
				$final-value: if($transform == 'rem', px-to-rem($value), $value);
				--#{$prefix}-#{$key}: #{$final-value};
			}
		}
	}
}

/// Check if map contains nested maps (first value is a map)
/// @access private
@function _is-nested-map($map) {
	@if meta.type-of($map) != 'map' {
		@return false;
	}
	@each $key, $value in $map {
		@return meta.type-of($value) == 'map';
	}
	@return false;
}
